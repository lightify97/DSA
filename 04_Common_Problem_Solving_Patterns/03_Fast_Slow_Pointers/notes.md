# Fast & Slow Pointers (Tortoise and Hare)

## 1. Introduction / Concept

Imagine two runners on a circular track. If one runner is faster than the other, and they both start at the same point, they are guaranteed to eventually meet again if the track is indeed circular. If the track is just a straight line, the faster runner will simply run away from the slower one without meeting again.

The **Fast & Slow Pointers pattern**, also known as the **Tortoise and Hare algorithm** (a reference to Aesop's fable), is a specialized application of the Two Pointers pattern. It uses two pointers that traverse a sequence (typically a Linked List or a sequence generated by a function) at different speeds. The primary application is to efficiently **detect cycles** within such sequences, but it can also be used to find the middle of a list, the start of a cycle, or the length of a cycle.

This pattern is highly efficient because it uses constant extra space.

## 2. Core Principles / Theory

The fundamental intuition behind cycle detection with Fast & Slow Pointers is based on relative speed.

*   **Initialization:** Both the `slow` pointer and the `fast` pointer typically start at the beginning (head) of the sequence.
*   **Movement:**
    *   The `slow` pointer moves one step at a time: `slow = slow.next`.
    *   The `fast` pointer moves two steps at a time: `fast = fast.next.next`.
*   **Cycle Detection Condition:**
    *   If there is **no cycle**, the `fast` pointer (and eventually `fast.next`) will reach the end of the sequence (i.e., become `None`). The loop will terminate.
    *   If there **is a cycle**, the `fast` pointer will eventually "catch up" to the `slow` pointer inside the cycle. This is because every time `slow` moves one step into the cycle, `fast` moves two. The distance between them effectively decreases by one step each time, guaranteeing a meeting point within the cycle.
        *(Imagine the two runners on a circular track; the faster one will eventually lap the slower one if they run long enough.)*

### Extensions to the Core Principle:

*   **Finding the Middle of a Linked List:**
    *   When the `fast` pointer reaches the end of the list (or `None`), the `slow` pointer will be at the middle of the list. This works for both even and odd length lists with slight adjustments on how `fast` terminates.
*   **Finding the Start of the Cycle:**
    *   Once `slow` and `fast` meet *inside* the cycle, reset `slow` to the head of the list.
    *   Then, move both `slow` and `fast` one step at a time (`slow = slow.next`, `fast = fast.next`).
    *   The point where they meet again is the start of the cycle.
        *(Intuition: The distance from head to cycle start is the same as the distance from meeting point to cycle start, assuming the fast pointer is `k` steps ahead of slow at the meeting point.)*
*   **Finding the Length of the Cycle:**
    *   Once `slow` and `fast` meet, keep one pointer (say `slow`) at the meeting point.
    *   Move the other pointer (`fast`) one step at a time, counting steps, until it meets `slow` again. The count is the length of the cycle.

## 3. Operations / Methods

The primary "operations" involve specific pointer advancements and comparisons:

*   `slow = head`, `fast = head`: Initialization.
*   `slow = slow.next`: Standard single step.
*   `fast = fast.next` or `fast = fast.next.next`: Double step.
*   `if slow == fast:`: The fundamental condition for cycle detection.
*   `while fast and fast.next:`: Common loop condition for the `fast` pointer to prevent `None` access for `fast.next.next`.

## 4. Python Implementation Details / Considerations

*   **`ListNode` Class:** This pattern is primarily used with custom `ListNode` objects (or similar node structures) that have a `next` attribute.
*   **Handling Empty or Single-Node Lists:** Always include checks for `head is None` or `head.next is None` to prevent errors and handle edge cases gracefully. Such lists cannot contain cycles.
*   **Object Identity:** In Python, `is` or `==` can be used to compare object identity (memory address) for `ListNode` objects, which is what's needed here to check if two pointers point to the *exact same node*.

### Example 1: Detecting a Cycle in a Linked List

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def has_cycle(head: ListNode) -> bool:
    # Edge cases: empty list or list with a single node cannot have a cycle.
    if not head or not head.next:
        return False

    slow = head
    fast = head

    # The loop continues as long as fast and fast.next are valid (not None)
    # This prevents errors if fast goes off the end of a non-cyclical list.
    while fast and fast.next:
        slow = slow.next        # Slow moves one step
        fast = fast.next.next   # Fast moves two steps

        if slow == fast: # If they meet, a cycle exists
            return True
            
    # If the loop finishes, it means fast reached the end, so no cycle
    return False

# Edge Cases and Examples (conceptual setup for testing):
# Test Case 1: No Cycle
head1 = ListNode(1, ListNode(2, ListNode(3)))
print(f"List 1 has cycle: {has_cycle(head1)}") # Output: False

# Test Case 2: Cycle
head2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
head2.next.next.next.next = head2.next # Creates cycle: 1 -> 2 -> 3 -> 4 -> (points back to 2)
print(f"List 2 has cycle: {has_cycle(head2)}") # Output: True

# Test Case 3: Empty List
head3 = None
print(f"List 3 has cycle: {has_cycle(head3)}") # Output: False

# Test Case 4: Single Node List
head4 = ListNode(1)
print(f"List 4 has cycle: {has_cycle(head4)}") # Output: False

# Test Case 5: Two Node List with Cycle
head5 = ListNode(1, ListNode(2))
head5.next.next = head5 # Creates cycle: 1 -> 2 -> (points back to 1)
print(f"List 5 has cycle: {has_cycle(head5)}") # Output: True
```
*   **Edge Cases Handled:** Empty list, single-node list, cycle involving two nodes. The `while fast and fast.next` ensures safety.

### Example 2: Finding the Middle of a Linked List

```python
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def find_middle(head: ListNode) -> ListNode:
    if not head:
        return None # Edge case: empty list

    slow = head
    fast = head

    while fast and fast.next: # As long as fast can move two steps
        slow = slow.next
        fast = fast.next.next
    
    return slow # When fast reaches end, slow is at the middle

# Edge Cases and Examples (conceptual setup for testing):
# Test Case 1: Odd Length List (1 -> 2 -> 3 -> 4 -> 5)
head1 = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5)))))
print(f"Middle of 1->2->3->4->5: {find_middle(head1).val}") # Output: 3

# Test Case 2: Even Length List (1 -> 2 -> 3 -> 4)
head2 = ListNode(1, ListNode(2, ListNode(3, ListNode(4))))
print(f"Middle of 1->2->3->4: {find_middle(head2).val}") # Output: 3 (Second middle node)

# Test Case 3: Single Node List
head3 = ListNode(1)
print(f"Middle of 1: {find_middle(head3).val}") # Output: 1

# Test Case 4: Empty List
head4 = None
print(f"Middle of empty list: {find_middle(head4)}") # Output: None
```
*   **Edge Cases Handled:** Empty list, single-node list. For even-length lists, this specific implementation returns the second of the two middle nodes, which is a common requirement.

## 5. Time and Space Complexity Analysis

The Fast & Slow Pointers pattern is renowned for its optimal efficiency.

*   **Time Complexity:**
    *   **O(N)**: Where N is the number of nodes in the linked list (or elements in the sequence).
    *   **Justification:** The `fast` pointer traverses the list roughly twice (or at most twice the length of the list before meeting the `slow` pointer in a cycle). The `slow` pointer traverses at most once. Each step is a constant time operation. Therefore, the total work is proportional to N.
*   **Space Complexity:**
    *   **O(1)**: (Constant space).
    *   **Justification:** Only a fixed number of extra variables (the two pointers) are used, regardless of the size of the input sequence. This makes it extremely memory-efficient.

## 6. Pros and Cons / Trade-offs

### Pros:
*   **Optimal Efficiency:** Achieves the best possible time complexity (O(N)) and space complexity (O(1)) for cycle detection and related problems in linked lists or sequence generation problems.
*   **No Auxiliary Data Structures:** Doesn't require hash sets or arrays to store visited nodes, which saves a lot of memory compared to other approaches for cycle detection.
*   **Versatility:** Beyond basic cycle detection, it can be extended to find the cycle's starting point, length, or the middle of a list.
*   **Works with Implicit Graphs:** Can be applied to problems where the sequence is generated by a function, implicitly forming a graph (e.g., Happy Number, where numbers map to other numbers).

### Cons:
*   **Specific Use Cases:** Highly specialized. It's primarily useful for problems involving cycles or needing to find midpoints in sequential data. It's not a general-purpose traversal or search algorithm.
*   **Tricky Pointer Logic:** Getting the pointer movements and loop termination conditions exactly right can be challenging initially. Off-by-one errors or `None` checks are common pitfalls. Drawing diagrams is highly recommended for complex scenarios.
*   **Not for all cycle types:** While excellent for detecting cycles in linked lists and certain sequences, it's not a universal cycle detection algorithm for arbitrary graphs (for that, DFS is more commonly used).

## 7. Common Use Cases / Applications

*   **Detecting Cycles in a Linked List:**
    *   The most common application. Checks if a loop exists.
    *   (e.g., LeetCode 141. Linked List Cycle)
*   **Finding the Starting Node of a Cycle in a Linked List:**
    *   After detecting a cycle, an extension of the algorithm can find where the cycle begins.
    *   (e.g., LeetCode 142. Linked List Cycle II)
*   **Finding the Middle of a Linked List:**
    *   When the fast pointer reaches the end, the slow pointer is at the middle.
    *   (e.g., LeetCode 876. Middle of the Linked List)
*   **Detecting Cycles in a Number Sequence:**
    *   Problems like "Happy Number" involve generating a sequence of numbers where eventually a cycle might form.
    *   (e.g., LeetCode 202. Happy Number)
*   **Finding the Duplicate Number in an Array:**
    *   If numbers are in a specific range and duplicates exist, the array can be viewed as a linked list where `nums[i]` points to `nums[nums[i]]`, forming a cycle due to the duplicate.
    *   (e.g., LeetCode 287. Find the Duplicate Number)
*   **Finding the Kth Node from the End of a Linked List:**
    *   Move the fast pointer `K` steps ahead, then move both `fast` and `slow` until `fast` reaches the end.
    *   *(Imagine a diagram with `fast` being `K` nodes ahead of `slow`.)*

## 8. Related Concepts / Variations

*   **Two Pointers:** The Fast & Slow Pointers pattern is a specific and powerful instance of the broader Two Pointers technique.
*   **Linked Lists:** The data structure where this pattern is most frequently applied.
*   **Floyd's Cycle-Finding Algorithm:** This is the formal name for the Tortoise and Hare algorithm.
*   **Hash Sets (for cycle detection):** An alternative method to detect cycles in linked lists by storing visited nodes in a hash set. While simpler to implement, it uses O(N) space, making Fast & Slow Pointers superior for space efficiency.

## 9. LeetCode Problem Examples

*   [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/) (Easy)
*   [142. Linked List Cycle II](https://leetcode.com/problems/linked-list-cycle-ii/) (Medium)
*   [876. Middle of the Linked List](https://leetcode.com/problems/middle-of-the-linked-list/) (Easy)
*   [202. Happy Number](https://leetcode.com/problems/happy-number/) (Easy)
*   [287. Find the Duplicate Number](https://leetcode.com/problems/find-the-duplicate-number/) (Medium)

## 10. Further Reading / Resources

*   [GeeksforGeeks - Floydâ€™s Cycle-Finding Algorithm](https://www.geeksforgeeks.org/floyds-cycle-finding-algorithm/) - Detailed explanation of the algorithm.
*   [Educative.io - Fast & Slow Pointers (from Grokking the Coding Interview)](https://www.educative.io/courses/grokking-the-coding-interview/N0o9AgNZE7M) - Part of a well-regarded interview prep course.
*   [Visualizing Floyd's Algorithm](https://en.wikipedia.org/wiki/Floyd%27s_cycle-finding_algorithm#/media/File:Floyd%27s_cycle-finding_algorithm_animation.gif) - An animated GIF can be very helpful for intuition.
*   [Khan Academy - Finding the middle of a linked list](https://www.khanacademy.org/computing/computer-science/algorithms/linked-lists/a/finding-middle-of-linked-list) - Simple explanation for the midpoint problem.
